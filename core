how java code executed:
-----------------------
JDK(Java development tool kit) -- it contains JRE(Java run time environment)[it contains JVM(java run time environment)]
javac fileName.java -- to compile java code
when we compile java code we get a byte code (fileName.class)

java code ---- javac fileName.java ---- gets the byte code(it is platform independent we can run it on any where, where we have JRE) --- .class

bytecode(*.class) --- JVM ----native code(mac, windows...)
we can run Java anywhere so Java is  platform-independent, JVM takes the byte code and converts it to native code to run in their OS(different os)
so this is the reason why Java is "platform independent", "portable"

Java was developed by James Gosling in 1995 and later acquired by Oracle in 2010.

Java features:
---------------
1. platform independent
2. portable
3. secure
4. Java is compiled and interpreted language
5. robust
6. oops

access modifiers:
----------------
1. private (only can access within the class, not outside the class, outside the package)
2. public (Access from anywhere)
3. protected (can access within a class, within the package, outside package by a subclass)
4. default (can access within in class, within package)

super keyword:
----------------
super keyword refers to the objects of the superclass. it is used when we want to call the superclass variable, methods, and constructor through a subclass object.
  -> Whenever the superclass and subclass variable and method name both are the same then only it can be used.
  -> To avoid confusion between superclass and subclass variables and methods that have the same name we should use the "super" keyword

                               ---------------------super----------------
                              |                      |                   |
                              variable            methods              constructor

syntax:
--------
class a{
  int a =10;
  a(int a){

   }
  void disp(){
    sysout("hello");
  }
}

class b extends a{
  int a = 30;
  void show(){
    super(100); //super class constructor
    sysout(super.a); //super class variable
    sysout(a);  
    sysout(super.disp()); //calling super class method
  }
}

static method:
--------------
if we declare methods as static we no need to initilize the objects, we can directly access it.
example:
--------
class a{
    public static void show(){
        System.out.println("hello");
    }

    public static void main(String[] arsg){ // since the main method have static we can execute directly
        a.show();
    } 
}

not static method(instance method):
------------------
class a{
    public void show(){
        System.out.println("hello");
    }

    public static void main(String[] arsg){ 
        a obj = new a();
        obj.show();
    } 
}

------------------------------------------------------------------
    access modifier  
---> public static void main(String[] args)
                   return type
this can be in any format not like the way above is, we can use it like as static public void main(String[] args).
------------------------------------------------------------------

Packages in Java:
-------------------
A Java package is a group of similar types of classes, interfaces, and sub-packages.
example:
--------
the package is nothing but a folder in Windows.

types of packages:
------------------
1. user-defined  (package add, package mypack etcc...)
2. pre-defined -- (java.lang, java.util, java.sql etc..)

advantages of packaging:
------------------------
1. re-usability
2. security
3. hiding (if we make a package1 of code and use that package1 in another code here we are hiding code which is in packag1)

disadvantages:
--------------
we cannot pass parameters to the package.

pre-defined
-------------
1. java.util -- this package is used to implement data structures in Java. it contains a utility class also called "collection framework".
example:
--------
LinkedList, stack, vector, HashSet, tree etc.

2. java.io-- io stands for input and output this package is used to perform input and output operations on file.

user-defined:
-------------
we make a package
to compile the user-defined package class we use ---  "javac -d . className.java"

multithreading:
----------------
multithreading is the process to execute multiple threads at the same time without depending on other threads.
-> Multithreading saves time 
suppose we have a program it is taking 20 mins to execute the code.
-> If we use the concept of the thread 
-> t1 thread will be executing half of the code
-> t2 thread will be executing another half 
threads execute simultaneously so both threads complete execution in 10 mins

thread:
-------
-> thread is a pre-defined class that is available in "java.lang" package.
-> thread is a basic unit of cpu and it is well known as independent execution.

example:
---------
main(){
withdraw();      -- t1
deposit();        --t2
checkBalance();  -- t3
}

-> We have three threads one thread is being assigned to one service, and whenever users come to access them
   suppose a user1 came to access withdraw(), another user2 deposit(), and another user3 checkBalance(), here all users are able to access them without being blocked and reduce time.
-> Without threads, it will be like when one user is accessing one service the others should wait because every service is being blocked.


multitasking:
--------------
Take the example of a laptop in a laptop we are running many applications at a time like opening Chrome, playing songs in Spotify, and coding in vs code and etc...
here we are making use of the CPU better and also reducing the time

creating a thread in Java:
------------------------
1. By extending the thread class.
2. By implementing a runnable interface.

1. By extending the thread class.
----------------------------------
import java.io.*;
import java.util.*;
public class GFG extends Thread {
	public void run()
	{
	    try{
	        System.out.println("Thread Started Running...");
	        Thread.sleep(1000); // it will wait for 1 sec
		    System.out.println("Thread Started Running...");
	    }
	    catch(Exception e){
	    }
	}
	public static void main(String[] args)
	{
		GFG g1 = new GFG();
		// Invoking Thread using start() method
		g1.start();
	}
}

2. By implementing a runnable interface.
-----------------------------------------
import java.io.*;
import java.util.*;

public class GFG implements Runnable {
	// method to start Thread
	public void run()
	{
		System.out.println(
			"Thread is Running Successfully");
	}

	public static void main(String[] args)
	{
		GFG g1 = new GFG();
		//g1.start() // thread wont start this way like how we did in "extends way", this runnable class deos not have power to start that thread
		// initializing Thread Object
		Thread t1 = new Thread(g1);
		t1.start();
	}
}

Thread Scheduler:
-----------------
-> A component of Java that decides which thread to run or execute and which thread to wait is called a thread scheduler in Java. 

thread is only chosen by a thread scheduler if it is in the runnable state. However, if there is more than one thread in the runnable state, 
it is up to the thread scheduler to pick one of the threads and ignore the other ones. There are some criteria that decide which thread will execute first. 
There are two factors for scheduling a thread i.e. Priority and Time of arrival.

Priority: 
------------
The priority of each thread lies between 1 to 10. If a thread has a higher priority, it means that the thread has got a better chance of getting picked up by the thread scheduler.

Time of Arrival:
------------------
Suppose two threads of the same priority enter the runnable state, then priority cannot be the factor to pick a thread from these two threads. In such a case,
the arrival time of the thread is considered by the thread scheduler. A thread that arrived first gets the preference over the other threads.

thread lifecycle:
------------------
we know that thread is well-known for independent execution. During the life cycle a thread can move from different states.

1. new state       (born state)
2. runnable state  (ready state)
3. running state   (execution state)
4. waiting state   (blocked state)
5. dead state      (exit state)

sleep() method:
--------------
sleep is a static method of thread class which shoes checked exception i.e IntruptedException.
the main purpose of the sleep method is to put a thread into a temporary waiting state.

syntax:         ____(milli seconds)
-------        |
Thread.sleep(1000);
or
Thread t = new Thread();
t.sleep(1000);

join() method
---------------
-> The main purpose of join is to put a thread into a temporary waiting state.
-> join method is used suppose we want to execute complete any particular thread among all the threads available in the thread pool.
-> The join method also throws a checked exception i.e. interrupted exception.

Example:
--------
class join extends Thread{
    public void run(){
    String name = Thread.currentThread().getName();
    for(int i=0;i<3;i++){
        System.out.println(name);
    }
    }
}
class b{
    public static void main(String[] args){
        join t1 =new join();
        join t2 =new join();
        join t3 =new join();

        t1.setName("thread 1");
        t2.setName("thread 2");
        t3.setName("thread 3");

        t2.start();
        try {
            t2.join(); // it will finishing executing thread 2 by putting t1 and t3 in temporary waiting state
        } catch (Exception e) {
            // TODO: handle the exception
        }
        t1.start();
        t3.start();
    }
}

suspend() method and resume method(); these are depricted after java 1.1 onwards
------------------------------------
-> The main purpose of suspend method it put the thread from a running state to a waiting state.
-> Resume method is used to resume a suspended thread from the waiting state to the running state.
example:
--------
public class suspend extends Thread {
    public void run(){
        String name = Thread.currentThread().getName();
        for(int i=0;i<3;i++){
            System.out.println(name);
        }
    }
    
}
public class a{
    public static void main(String[] args){
        suspend t1 = new suspend();
        suspend t2 = new suspend();
        suspend t3 = new suspend();
        t1.setName("thread 1");
        t2.setName("thread 2");
        t3.setName("thread 3");

        t1.start();
        t2.suspend();
        t3.start();
        t2.resume();
    }
}


stop() method:
--------------
stop is a method of thread class that is used to terminate a thread permanently.

example:
---------
public class stop extends Thread{
    public void run(){
        String name = Thread.currentThread().getName();
        for(int i=0;i<3;i++){
            System.out.println(name);
        }
    }
    
}
public class tharunk{
    public static void main(String[] args){
    stop t1 = new stop();
    stop t2 = new stop();
    stop t3 = new stop();
    t1.setName("thread 1");
    t2.setName("thread 2");
    t3.setName("thread 3");

    t1.start();
    t2.start();;
    t3.start();
    t2.stop();
    }
}
yeild() method:
---------------
A yield() method is a static method of the Thread class and it can stop the currently executing thread and will give a chance to other waiting threads of the same priority.

isAlive() method:
------------------
isAlive() method is a pre-defined method of thread class through which we can verify whether a thread is alive or not.
-> If a thread is alive it will return true else false.
-> If we run the alive() method before starting the thread it will return false.

thread priority:
-----------------
In Java, it is possible to set the priority of threads.
-> To set these priorities java thread class provided two pre-defined methods.
	->setpriority()
	->getpriority()

the thread class also provided three pre-defined final state variables and their value lie between 1 to 10.
Thread.MIN_PRIORITY = 1
Thread.NORM_PRIORITY = 5
Thread.MAX_PRIORITY = 10

-> If we won't set any priority to the threads JVM by default is set to NORMAL priority which is 5.

example:
----------
public class priority extends Thread{
    public void run(){
        int priority =  Thread.currentThread().getPriority();
        String name = Thread.currentThread().getName();
        System.out.println(name+" "+ priority);
    }
    
}
class ketineni {
    public static void main(String[] args){
        priority t1 = new priority();
        priority t2 = new priority();
        priority t3 = new priority();
        t1.setName("thread 1");
        t2.setName("thread 2");
        t3.setName("thread 3");

        t1.setPriority(5);
        t2.setPriority(10);
        t3.setPriority(8);
        t1.start();
        t2.start();
        t3.start();
    }
}



this keyword:
-------------
