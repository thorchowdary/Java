Oops, concepts:
--------------
1. polymorphism
2. encapsulation
3. inheritance
4. abstraction

1. polymorphism:
----------------
poly --many
morphism -- forms

polymorphism is a Greek word whose meaning is "same object having different forms"

example:
--------
    one person can be a student, teacher, friend, or customer.

polymorphism can be achieved in two ways
1. runtime polymorphism (method overriding)
2. compile time polymorphism (method overloading)

1. runtime:
------------
class a{
  void show(){  -->show() method exists here, we can override in the child class
  system.out.println("hello);  
  }
}

class b extends a{

we are overriding the method in the superclass.
to override the method there should be a method in the superclass without having a method in the superclass if we try to override it will give an error
to call the superclass method output we use the super keyword

super.show();
@override
void show(){
sysout("hi")
}
}

2.compiletime(method overloading)
----------------------------------
the same method in different forms, they get differentiated with the parameters passed to that method

void show(int a){
sysout("a");
}
void show(int a,int b){
sysout("ab");
}
void show(int a,int b, int c){
sysout("abc");
}

when we call
show(1);
show(1,2);
show(1,2,3);

this is called method overloading



2. encapsulation:
--------------------
wrapping out data members and member methods in a single class is called encapsulation.

note:
----
1. declare class members as private
2. methods as public

* encapsulation also does data hiding(by making class members private) and abstraction.


class a {
private int a; --- data hiding // we cannot access the private variables outside only class methods can access them, if we try to assign a value to it from outside it will 
                                  throw an error, that is the reason we are setting the a value with the x argument.
void setValue(int x){ ---->absraction is happing by hiding the unwanted information from the user, also we are setting value a by passing an argument x.
 a =  x ;
}
void getValue(){
sysout(value);
}
public static void main(String args[]){
bag a = new a();
a.setvalue(10);
sysout(a.getvalue);

}
}

3. inheritance:
------------------
when we construct a new class from an existing class in such a way that the new class access all the features and properties of an existing class.
    -> in java we use extends keyword to perform inheritance
    -> It provides code re-usability
    -> We can't access private members of the class through inheritance.
    -> Method overriding is only possible through inheritance.

syntax:
-------

class a{ //super class
------
}
class b extends a{ //sub class

}

types of inheritance:
-----------------------
1. single/simple inheritance:
 ------------------------------
simple inheritance is that contains only one superclass and one subclass.
superclass
 |
 |
subclass

2. multi-level inheritance:
--------------------------
in multi-level inheritance, we have only one superclass and multiple subclasses.
superclass
    |
subclass 1
    |
subclass 2
    |
subclass 3 and so on.......

syntax:
------
class a { //superclass

}
class b extends a{ //subclass1

}
class c extends b{ //subclass2

}

3. multiple inheritance
------------------------
java does not support multiple inheritances
whenever a subclass wants to inherit the property of two or more superclasses that have the same method the Java compiler can't decide which class methods should inherit.
then there will be a chance of memory duplication i.e. reason java does not support multiple inheritance.

super class1            super class2
      |                      |
      ------>subclass<-------

syntax:
--------
class a { //superclass
    void m1(){
    }
}

class b { //superclass
    void m1{
    }
}

class c extends a,b{ //subclass
  c in confusion
}

suppose superclass1 and superclass2 have the same service when the subclass extends with both the classes will get an ambiguity as to which service to use, so java
does not support multiple inheritance.

with the help of interfaces, we can achieve multiple inheritance.

4. hierarchical inheritance:
-----------------------------
an inheritance that contains only one superclass and multiple subclasses, and all subclassed are directly extended from the superclass.


    ----- superclass -------
    |        |             |
subclass1   subclass2    subclass3

syntax:
--------
class a{ //superclass

}

class b extends a{ //subclass1

}

class c extends a{ //subclass2

}

4. abstraction:
---------------
abstraction is the process of hiding the implementation details from the user, only highlighting a set of services provided to the user.

example:
--------

    calculator app( it has add() ,sub() ,mul() ,div() features)-----user just uses the service we don't display the code and logic and which language to the user 

advantages :
----------
1. security -- by hiding the core logic and displaying necessary services to the user.
2. enhancement -- we can enhance the code written or also we can change from one language to another language.

abstraction can be implemented in two ways:
---------------------------------------------
1. Abstraction
2. Interface

1. abstract class:
------------------
a class that contains the abstract keyword in its declaration is called an abstract class.
syntax:
-------
abstract class a{

}

-> We can't create objects from the abstract class.
-> It can have abstract and non-abstract methods.
-> It may or may not have abstract methods.
-> To use an abstract class we need to inherit from the subclass.
-> If a class contains partial implementation then we should declare a class as abstract.
-> When the method is abstract method then the class should be an abstract class.

syntax:
-------
case 1:
-------
abstract class a{
    abstract void m1();{ // here method is abstract then the class should be abstract.

    }
}

case 2:
-------
abstract class a{
    public void m1(); //this is a partial implementation we just declared the method but we didn't do any implementation.
}

example:
---------

abstract class animal{
    animal(){
        sysout("all animals"); // constructor
    }
    abstract void sound(); // here we just declaring the method not doing implementation because different animal makes different sound so, this is partial implementation,
}

class dog extends animal{
    dog(){
        super(); //calling abstract method constructor
    }
    public void sound(){
        sysout("baw");
    }

}

class cat extends animal{
    cat(){
        super(); 
    }
     public void sound(){
            sysout("meowww");
    }
}


interface:
-----------
the interface is just a class that contains only an abstract method.
-> To achieve an interface java provides a keyword called "implements".
-> interface methods are by default public and abstract.
-> interface variables are by default public + static + final.
-> Interface methods should be overridden inside the implementation class.
-> Whatever methods we do declare in the interface we need to implement in the subclasses otherwise will get an error.
syntax:
-------

interface client{
    int amt = 5; // public + static + final;
    void input();
    void output(); // by default methods are abstract + public
}
class a implements client{
    @override
    public void input(){
        amt = 5// you cannot assign a value to the amt variable since it is final(fixed);
        sysout("hello" + amt);
        client.amt; // since static variables no need initializing objects and access from it since we cannot initialize an object to interfaces we need to implement it.
    }
    @override
    public void output(){
        sysout("hi"+amt);
    }
}
-> Whatever methods we do declare in the interface we need to implement in the subclasses otherwise will get an error.

interface animal{
    void eat(); // public + abstract
    void sound(); // public + abstract
}

abstract class dog implements animal{
    @override
    public void eat(){
        sysout("chicken");    // here in this abstract class we are not using both the methods which are in interface will get an error so we can use them by extending in another class.
    }
}

class cat extends dog{
    @override
    public void sleep(){
        sysout("sleeppppp"); // here we used another method in interface.
    }
}

public static void main(String args[]){
cat a = new cat(); // we can use of both the methods by initializing the single object
a.eat();
a.sleep();
}


multiple inheritance can be achieved by interface:
--------------------------------------------------
we can achieve multiple inheritace through interfaces because interface contains only abstract method, which implementation is provided by the sub class.

 method1           method2 
interface a      interface b
     |              |
     ----class c----


class c implements a,b
